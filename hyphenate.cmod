/*! @module Public
 */

/*! @module Tools
 */

/*! @module Language
 */

#define _GNU_SOURCE
#define DEFAULT_CMOD_STORAGE

#include "hyphenate_config.h"
#include "util.h"
#include "altlinux/hyphen.h"
#include "altlinux/csutil.h"


/*! @class Hyphenate
 */

PIKECLASS Hyphenate
{

CVAR     HyphenDict * dict;


/*! @decl void create(string appname)
 *!   Creates a new Public.Sample.Sample object
 *!
 */
PIKEFUN void create(string dictionary)
{
  HyphenDict * hd;
  char * dn;
  dn = strdup(dictionary->str);
  hd = hnj_hyphen_load(dn);

  if(!hd)
  {
    Pike_error("unable to load hyphenation dictionary.\n");
  }

  THIS->dict = hd;

  pop_n_elems(args);
}

PIKEFUN string hyphenate(string word)
{
int k, n, i, j, c;

int  nHyphCount;
char *hyphens;
char *lcword;
char *hyphword;

k = word->len;

  /* set aside some buffers to hold lower cased */
  /* and hyphen information */
  lcword = (char *) malloc(k+1);
  hyphens = (char *)malloc(k+5);
  enmkallsmall(lcword,word->str,THIS->dict->cset);

  n = strlen(lcword);

  if (k > 0) {
    if(hnj_hyphen_hyphenate(THIS->dict, lcword, n-1, hyphens))
    {
        free(hyphens);
        free(lcword);
	pop_n_elems(args);
        Pike_error("hyphenation error\n");
       }

       /* now backfill hyphens[] for any removed periods */
       for (c = n; c < k; c++) hyphens[c] = '0';
       hyphens[k] = '\0';

       /* now create a new char string showing hyphenation positions */
       /* count the hyphens and allocate space for the new hypehanted string */
       nHyphCount = 0;
       for (i = 0; i < n; i++)
          if (hyphens[i]&1)
             nHyphCount++;
       hyphword = (char *) malloc(k+1+nHyphCount);
       j = 0;
      for (i = 0; i < n; i++) {
          hyphword[j++] = word->str[i];
          if (hyphens[i]&1)
          {
              hyphword[j++] = '-';
          }
}
	       hyphword[j] = '\0';
	
		   pop_n_elems(args);
	       push_text(hyphword);
	       free(hyphens);
	       free(lcword);
	       free(hyphword);
//	    }
		}
}


INIT
{
    THIS->dict = NULL;
}

EXIT 
{
  if(THIS->dict)
  {
    free(THIS->dict);
  }
}

}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */

/*! @endmodule
 */


